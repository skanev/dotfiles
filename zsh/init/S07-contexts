#!/usr/bin/env zsh
# CONTEXTS
# --------
#
# This scripts allow defining project-local aliases, functions and keybindings.
#
# Each context is defined in a directory under some in $c_dirs and looks like
# this:
#
#   contexts/
#     dotfiles/
#       detect
#       zsh
#     another/
#       ...
#
# This:
#
# - defines a context named "dotfiles"
# - the "detect" file contains patterns, one per line, that specify when the
#   context is enabled
# - the "zsh" file contains local zsh stuff (functions, aliases, bindings) that
#   are available when the context is enabled
#
# There is some obscure ZSH and AWK here, which I'm pretty proud of.

# --- VARIABLES AND OPTIONS ------------------------------------------------------------------------

c_dirs=($DOTFILES/contexts)

[[ -n $DOTFILES_CONTEXTS_EXTRA ]] && c_dirs+=( ${(s#:#)${DOTFILES_CONTEXTS_EXTRA//\~\//$HOME/}} )

typeset -ag c_available          # Stores the names of available contexts
typeset -Ag c_available_patterns # Stores name -> pattern1,pattern2
typeset -Ag c_available_location # Stores name -> ~/context-dir/name
typeset -Ag c_current            # Data about the current context
typeset -ag c_revert             # When in a context, commands that would unload the context

c_available_patterns=()
c_available_location=()
c_available=()

# --- LOADING AND UNLOADING ------------------------------------------------------------------------

c-load-available-contexts() {
  local name patterns location dir

  for dir in $c_dirs; do
    for file in $dir/*/detect(N); do
      name=${file:h:t}
      patterns=${(j#,#)${(f)"$(< $file)"}}
      location=${file:h}

      if [[ -n $c_available_patterns[$name] ]]; then
        print "contexts: '$name' already defined in $location" 1>&2
      fi

      c_available+=($name)
      c_available_patterns[$name]=$patterns
      c_available_location[$name]=$location
    done
  done
}

c-chpwd() {
  local -aU matches
  local first name pattern

  matches=()

  for name in $c_available; do
    for pattern in ${(s#,#)c_available_patterns[$name]}; do
      if [[ $PWD/ == $~pattern ]]; then
        matches+=($name)
      fi
    done
  done

  first=${matches[1]}

  case "$#matches/${c_current[name]}" in
    0/)
      ;;

    0/*)
      c-unload
      ;;

    1/$first)
      ;;

    1/*)
      c-unload
      c-load $first
      ;;

    *)
      local message
      message=${(j:, :)matches}
      print "contexts: conflict $message" 1>&2
      ;;
  esac
}

c-load() {
  if [[ -n $c_current[name] ]]; then
    print "contexts: Can't load $1: already loaded ${c_current[name]}" 1>&2
    return
  fi

  local name file revert context_dir

  context_dir=$c_available_location[$1]
  file=$context_dir/zsh

  c_current[name]=$1
  c_current[dir]=$context_dir
  [[ -e $context_dir/zsh ]] && c_current[zsh]=$context_dir/zsh
  [[ -e $context_dir/mux ]] && c_current[mux]=$context_dir/mux
  c_revert=""

  if [[ -n $c_current[mux] ]]; then
    export MUX_CONFIG=$c_current[mux]
    export MUX_SESSION=$1
    c_revert+=('unset MUX_CONFIG')
    c_revert+=('unset MUX_SESSION')
  fi

  [[ -e $c_current[zsh] ]] || return

  awk -f <(cat <<\END
  /^[-a-zA-Z0-9_]+[[:space:]]*\(\)[[:space:]]*{/ { gsub("\\(\\)", "", $1); print "function", $1; }
  /^function[[:space:]]/ { gsub("\\(\\)", "", $2); print "function", $2; }
  /^alias [-a-zA-Z0-9_]+=/ { gsub("=.*", "", $2); print "alias", $2; }
  /^alias -g [-a-zA-Z0-9_]+=/ { gsub("=.*", "", $3); print "galias", $3; }
  /^bindkey / { print "bindkey -L", $2; }
  /^zle -N / { print "widget", $3; }
END
  ) $c_current[zsh] |
  while read -r line; do
    name=${${(s: :)line}[2]}

    case $line in
      alias*)
        if [[ -n $aliases[$name] ]]; then
          revert=$(alias -L $name)
        else
          revert="unalias $name"
        fi
        ;;

      galias*)
        if [[ $(whence -v $name) == *global\ alias* ]]; then
          revert=$(alias -L $name)
        else
          revert="unalias '$name'"
        fi
        ;;

      function*)
        if [[ -n $functions[$name] ]]; then
          revert="$name () {"$'\n'$functions[$name]$'\n}'
        else
          revert="unfunction $name"
        fi
        ;;

      bindkey*)
        revert=$(eval $line)
        ;;

      widget*)
        revert="zle -D $name"
        ;;

      *)
        continue
        ;;
    esac

    c_revert+=($revert)
  done

  source $c_current[zsh]
}

c-unload() {
  eval ${(F)c_revert}

  c_current=()
  c_revert=
}

c-load-available-contexts
chpwd_functions=(${chpwd_functions[@]} "c-chpwd")
c-chpwd

# --- FUNCTIONS TO WORK WITH CONTEXTS --------------------------------------------------------------

# All are prefixed with c-fun because ZSH does not do public and private

c-fun-list-all() {
  () {
    local location patterns name
    local -a files

    echo "NAME : LOCATION : PATTERN : FILES"

    for name in $c_available; do
      location=$c_available_location[$name]
      patterns=$c_available_patterns[$name]
      files=($location/*(N:t))
      files=(${files:#detect})

      location=${location/$HOME/'~'}

      echo $name : $location : $patterns : ${(j# #)files}
    done
  } | column -t -s ':'
}

c-fun-new-context() {
  setopt local_options err_return pushd_silent

  local name=$1
  local dir=$c_dirs[1]

  if [[ -z $name ]]; then
    >&2 echo "error: need a context name"
    false
  fi

  if [[ -d $dir/$name ]]; then
    >&2 echo "error: context $name already exists"
    false
  fi

  echo "Creating a new context in $dir/$name"

  pushd $dir

  mkdir $name
  pushd $name

  touch detect
  touch buffer.vim
  touch folder.vim
  echo "#!/usr/bin/env zsh" > zsh
  echo "#!/usr/bin/env zsh" > mux

  popd
  popd

  echo ""
  echo "Done. You can run this to open it:"
  echo ""
  echo "  vim $dir/$name"
  echo ""
}

context() {
  if (( $#c_current == 0 )); then
    echo "No context for the current directory" >&2
    false
    return
  fi

  local cmd=${1:-show}

  case $cmd in
    (show)
      for key in ${(k)c_current}; do
        printf "%-10s %s\n" "$key:" $c_current[$key]
      done

      if [[ -e $c_current[zsh] ]]; then
        echo "-------- zsh --------"
        cat $c_current[zsh]
        echo
      fi

      if [[ -e $c_current[mux] ]]; then
        echo "-------- mux --------"
        cat $c_current[mux]
        echo
      fi
      ;;

    (new)
      c-fun-new-context $2
      ;;

    (list)
      c-fun-list-all
      ;;

    (mux)
      vi $c_current[dir]/mux
      ;;

    (zsh|-e)
      vi $c_current[dir]/zsh
      e
      ;;
  esac
}

has-mux-context() {
  [[ -n $MUX_CONFIG ]]
}
