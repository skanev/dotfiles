#!/usr/bin/env zsh

# CONTEXTS
# --------
#
# This scripts allow defining project-local aliases, functions and keybindings.
#
# Each context is defined in a directory under some in $c_dirs and looks like
# this:
#
#   contexts/
#     dotfiles/
#       detect
#       zsh
#     another/
#       ...
#
# This:
#
# - defines a context named "dotfiles"
# - the "detect" file contains patterns, one per line, that specify when the
#   context is enabled
# - the "zsh" file contains local zsh stuff (functions, aliases, bindings) that
#   are available when the context is enabled
#
# There is some obscure ZSH and AWK here, which I'm pretty proud of.

c_dirs=(~/.zsh/contexts)

[[ -v context_extra_dirs ]] && c_dirs+=($context_extra_dirs)

typeset -a c_available          # Stores the names of available contexts
typeset -A c_available_patterns # Stores name -> pattern1,pattern2
typeset -A c_available_location # Stores name -> ~/context-dir/name

c_available_patterns=()
c_available_location=()
c_available=()

c-load-available-contexts() {
    local name patterns location

    for dir in $c_dirs; do
        for file in $dir/*/detect(N); do
            name=${file:h:t}
            patterns=${(j#,#)${(f)"$(< $file)"}}
            location=${file:h}

            if [[ -n $c_available_patterns[$name] ]]; then
                print "contexts: '$name' already defined in $location" 1>&2
            fi

            c_available+=($name)
            c_available_patterns[$name]=$patterns
            c_available_location[$name]=$location
        done
    done
}

c-chpwd() {
    local -aU matches
    local first

    matches=()

    for name in $c_available; do
        for pattern in ${(s#,#)c_available_patterns[$name]}; do
            if [[ $PWD/ == $~pattern ]]; then
                matches+=($name)
            fi
        done
    done

    first=${matches[1]}

    case "$#matches/$c_current" in
        0/)
            ;;

        0/*)
            c-unload
            ;;

        1/$first)
            ;;

        1/*)
            c-unload
            c-load $first
            ;;

        *)
            print "contexts: Conflict ${(j:, :)matches}" 1>&2
            ;;
    esac
}

c-load() {
    if [[ -n $c_current ]]; then
        print "contexts: Can't load $1: already loaded $c_current" 1>&2
        return
    fi

    local name file revert context_dir

    context_dir=$c_available_location[$1]
    file=$context_dir/zsh

    c_current=$1
    c_revert=""

    [[ -e $file ]] || return

    if [[ -z $TMUX && -e $context_dir/mux ]]; then
        export MUX_CONFIG=$context_dir/mux
        export MUX_SESSION=$1
        c_revert+="unset MUX_CONFIG"
        c_revert+=$'\n'
        c_revert+="unset MUX_SESSION"
        c_revert+=$'\n'
    fi

    awk -f <(cat <<\END
      /^[-a-zA-Z0-9_]+[[:space:]]*\(\)[[:space:]]*{/ { gsub("\\(\\)", "", $1); print "function", $1; }
      /^function[[:space:]]/ { gsub("\\(\\)", "", $2); print "function", $2; }
      /^alias [-a-zA-Z0-9_]+=/ { gsub("=.*", "", $2); print "alias", $2; }
      /^alias -g [-a-zA-Z0-9_]+=/ { gsub("=.*", "", $3); print "galias", $3; }
      /^bindkey / { print "bindkey -L", $2; }
      /^zle -N / { print "widget", $3; }
END
    ) $file |
    while read -r line; do
        name=${${(s: :)line}[2]}

        case $line in
            alias*)
                if [[ -n $aliases[$name] ]]; then
                    revert=$(alias -L $name)
                else
                    revert="unalias $name"
                fi
                ;;

            galias*)
                if [[ $(whence -v $name) == *global\ alias* ]]; then
                    revert=$(alias -L $name)
                else
                    revert="unalias '$name'"
                fi
                ;;

            function*)
                if [[ -n $functions[$name] ]]; then
                    revert="$name () {"$'\n'$functions[$name]$'\n}'
                else
                    revert="unfunction $name"
                fi
                ;;

            bindkey*)
                revert=$(eval $line)
                ;;

            widget*)
                revert="zle -D $name"
                ;;

            *)
                continue
                ;;
        esac

        c_revert+=$revert
        c_revert+=$'\n'
    done

    source $file
}

context() {
    if [[ -n $c_current ]]; then
        local file=$c_available_location[$c_current]/zsh

        if [[ $1 == "-e" ]]; then
            vim $file
            e
        else
            cat $file
        fi
    else
        echo "No context for the current directory"
    fi
}

c-unload() {
    eval $c_revert

    c_current=
    c_revert=
}

c-load-available-contexts

chpwd_functions=(${chpwd_functions[@]} "c-chpwd")

c-chpwd
