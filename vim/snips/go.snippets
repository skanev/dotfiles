snippet v "'shorthand variable declaration'"
${1} := ${2}

endsnippet

snippet vr "'variable initialization'"
var ${1:t} ${0:string}

endsnippet

snippet ap "'append'"
append(${1:slice}, ${0:value})

endsnippet

snippet bl "'bool'"
bool

endsnippet

snippet bt "'byte'"
byte

endsnippet

snippet br "'break'"
break

endsnippet

snippet ch "'channel'"
chan ${0:int}

endsnippet

snippet cs "'case'"
case ${1:value}:
	${0:${VISUAL}}

endsnippet

snippet co "'constants with iota'"
const (
	${1:NAME1} = iota
	${0:NAME2}
)

endsnippet

snippet cn "'continue'"
continue

endsnippet

snippet df "'defer'"
defer ${0:func}()

endsnippet

snippet dfr "'defer recover'"
defer func() {
	if err := recover(); err != nil {
		${0:${VISUAL}}
	}
}()

endsnippet

snippet im "'import'"
import (
	"${1:package}"
)

endsnippet

snippet in "'interface'"
interface{}

endsnippet

snippet inf "'full interface '"
interface ${1:name} {
	${2:/* methods */}
}

endsnippet

snippet ife "'if else condition'"
if ${1:/* condition */} {
	${2:${VISUAL}}
} else {
	${0}
}

endsnippet

snippet el "'else'"
else {
	${0:${VISUAL}}
}

endsnippet

snippet ir "'if error not nil, return err'"
if err != nil {
	return err
}
${0}

endsnippet

snippet f "'false'"
false

endsnippet

snippet ft "'fallthrough'"
fallthrough

endsnippet

snippet fl "'float'"
float32

endsnippet

snippet f3 "'float32'"
float32

endsnippet

snippet f6 "'float64'"
float64

endsnippet

snippet for "'for loop'"
for ${1}{
	${0:${VISUAL}}
}
endsnippet

snippet fori "'for int loop'"
for ${2:i} := 0; $2 < ${1:count}; $2${3:++} {
	${0:${VISUAL}}
}
endsnippet

snippet forr "'for range loop'"
for ${1:e} := range ${2:collection} {
	${0:${VISUAL}}
}
endsnippet

snippet fun "'function'"
func ${1:funcName}(${2}) ${3:error} {
	${4}
}
${0}

endsnippet

snippet fum "'method'"
func (${1:receiver} ${2:type}) ${3:funcName}(${4}) ${5:error} {
	${6}
}
${0}

endsnippet

snippet fumh "'http handler function on receiver'"
func (${1:receiver} ${2:type}) ${3:funcName}(${4:w} http.ResponseWriter, ${5:r} *http.Request) {
	${0:${VISUAL}}
}

endsnippet

snippet lf "'log printf'"
log.Printf("%${1:s}", ${2:var})

endsnippet

snippet lp "'log println'"
log.Println("${1}")

endsnippet

snippet mk "'make'"
make(${1:[]string}, ${0:0})

endsnippet

snippet mp "'map'"
map[${1:string}]${0:int}

endsnippet

snippet main "'func main()'"
func main() {
	${1}
}
${0}

endsnippet

snippet nw "'new'"
new(${0:type})

endsnippet

snippet pa "'package'"
package ${1:main}

endsnippet

snippet pn "'panic'"
panic("${0:msg}")

endsnippet

snippet pf "'fmt.Printf()'"
fmt.Printf("%${1:s}\n", ${2:var})

endsnippet

snippet pl "'fmt.Println()'"
fmt.Println("${1:s}")

endsnippet

snippet rn "'range'"
range ${0}

endsnippet

snippet rt "'return'"
return ${0}

endsnippet

snippet rs "'result'"
result

endsnippet

snippet sl "'select'"
select {
case ${1:v1} := <-${2:chan1}
	${3}
default:
	${0}
}

endsnippet

snippet sr "'string'"
string

endsnippet

snippet st "'struct'"
struct ${1:name} {
	${2:/* data */}
}
${0}

endsnippet

snippet sw "'switch'"
switch ${1:var} {
case ${2:value1}:
	${3}
case ${4:value2}:
	${5}
default:
	${0}
}

endsnippet

snippet ps "'fmt.Sprintf'"
fmt.Sprintf("%${1:s}", ${2:var})

endsnippet

snippet t "'true'"
true

endsnippet

snippet g "'goroutine named function'"
go ${1:funcName}(${0})

endsnippet

snippet ga "'goroutine anonymous function'"
go func(${1} ${2:type}) {
	${3:/* code */}
}(${0})

endsnippet

snippet test "'test function'"
func Test${1:name}(t *testing.T) {
	${0:${VISUAL}}
}

endsnippet

snippet testt "'table test function'"
func Test${1:name}(t *testing.T) {
	tests := []struct {
		name string
	}{
		{
			name: "${2:test name}",
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			${0:${VISUAL}}
		})
	}
}

endsnippet

snippet bench "'benchmark function'"
func Benchmark${1:name}(b *testing.B) {
	for i := 0; i < b.N; i++ {
		${2}
	}
}
${0}

endsnippet

snippet cl "'composite literals'"
type ${1:name} struct {
	${2:attrName} ${3:attrType}
}

endsnippet

snippet om "'if key in a map'"
if ${1:value}, ok := ${2:map}[${3:key}]; ok == true {
	${4:/* code */}
}


endsnippet

snippet gg "'Grouped globals with anonymous struct'"
var ${1:var} = struct{
	${2:name} ${3:type}
}{
	$2: ${4:value},
}


endsnippet

snippet ja "'Marshalable json alias'"
type ${1:parentType}Alias $1

func (p *$1) MarshalJSON() ([]byte, error) {
	return json.Marshal(&struct{ *$1Alias }{(*$1Alias)(p)})
}


endsnippet

snippet errwr "'Error handling with fmt.Errorf'"
if ${1}err != nil {
	return fmt.Errorf("${2} %w", err)
}
endsnippet

# Snippets for Go

priority -50

# when to abbriviate and when not?
# b doesn't work here, because it ignores whitespace
# optional local name?
snippet /^import/ "Import declaration" r
import (
	"${1:package}"
)
endsnippet

snippet /^package/ "Package declaration" r
// Package $1 provides ...
package ${1:main}
endsnippet

# Mostly converted from: https://github.com/AlanQuatermain/go-tmbundle
snippet /^cons/ "Constants declaration" r
const (
	${1:constant}${2/(.+)/ /}${2:type} = ${0:value}
)
endsnippet

snippet /^con/ "Constant declaration" r
const ${1:name}${2/(.+)/ /}${2:type} = ${0:value}
endsnippet

snippet iota "Iota constant generator" b
const (
	${1:constant}${2/(.+)/ /}${2:type} = iota
)
endsnippet

snippet struct "Struct declaration" b
type ${1:Struct} struct {
	${0:${VISUAL}}
}
endsnippet

snippet interface "Interface declaration" b
type ${1:Interface} interface {
	${0:${VISUAL}}
}
endsnippet

snippet if "If statement" b
if ${1:condition}${1/(.+)/ /}{
	${0:${VISUAL}}
}
endsnippet

snippet switch "Switch statement" b
switch ${1:expression}${1/(.+)/ /}{
case$0
}
endsnippet

# functions
snippet /^main/ "Main function" r
func main() {
	${0:${VISUAL}}
}
endsnippet

snippet /^meth/ "Method" r
func (${1:receiver} ${2:type}) ${3:name}(${4:params})${5/(.+)/ /}${5:type} {
	${0:${VISUAL}}
}
endsnippet

snippet func "Function" b
func ${1:name}(${2:params})${3/(.+)/ /}${3:type} {
	${0:${VISUAL}}
}
endsnippet

snippet funch "HTTP handler" b
func ${1:handler}(${2:w} http.ResponseWriter, ${3:r} *http.Request) {
	${0:${VISUAL}}
}
endsnippet

# types and variables
snippet map "Map type" b
map[${1:keytype}]${2:valtype}
endsnippet

snippet : "Variable declaration :=" b
${1:name} := ${0:value}
endsnippet

snippet var "Variable declaration" b
var ${1:name}${2/(.+)/ /}${2:type}${3: = ${0:value}}
endsnippet

snippet vars "Variables declaration" b
var (
	${1:name}${2/(.+)/ /}${2:type}${3: = ${0:value} }
)
endsnippet

snippet json "JSON field"
\`json:"${1:displayName}"\`
endsnippet

# vim:ft=snippets:

# error handling
snippet err "Basic error handling" b
if err != nil {
	log.${1:Fatal}(err)
}
endsnippet
