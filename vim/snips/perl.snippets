snippet #!
#!/usr/bin/env perl

endsnippet

snippet eif
elsif (${1}) {
	${0}
}
endsnippet

# While Loop
snippet wh
while (${1}) {
	${0}
}
endsnippet

# While Loop One-line
snippet xwh
${1:expression} while ${2:condition};
endsnippet

# C-style For Loop
snippet cfor
for (my $${2:var} = 0; $$2 < ${1:count}; $$2${3:++}) {
	${0}
}
endsnippet

# For loop one-line
snippet xfor
${1:expression} for @${2:array};
endsnippet

# Foreach Loop
snippet for
foreach my $${1:x} (@${2:array}) {
	${0}
}
endsnippet

# Foreach Loop One-line
snippet fore
${1:expression} foreach @${2:array};
endsnippet

# Package
snippet package
package ${1:`!v expand('%:p:s?.*lib/??:r:gs?/?::?')`};
use strict;
use warnings;

${0}

1;

__END__
endsnippet

# Package syntax perl >= 5.14
snippet packagev514
package ${1:`!v expand('%:p:s?.*lib/??:r:gs?/?::?')`} ${2:0.99};
use v5.14;
use warnings;

${0}

1;

__END__
endsnippet

#moose
snippet moose
use Moose;
use namespace::autoclean;
${1:#}BEGIN {extends '${2:ParentClass}'};

${0}
endsnippet

# parent
snippet parent
use parent qw(${0:Parent Class});
endsnippet

# strict warnings
snippet strwar
use strict;
use warnings;
endsnippet

# older versioning with perlcritic bypass
snippet vers
## no critic
our $VERSION = '${0:version}';
eval $VERSION;
## use critic
endsnippet

# new 'switch' like feature
snippet switch
use feature 'switch';

endsnippet

# Anonymous subroutine
snippet asub
sub {
	${0}
}



endsnippet

# Begin block
snippet begin
BEGIN {
	${0}
}

endsnippet

# call package function with some parameter
snippet pkgmv
__PACKAGE__->${1:package_method}(${0:var})

endsnippet

# call package function without a parameter
snippet pkgm
__PACKAGE__->${0:package_method}()

endsnippet

# call package "get_" function without a parameter
snippet pkget
__PACKAGE__->get_${0:package_method}()

endsnippet

# call package function with a parameter
snippet pkgetv
__PACKAGE__->get_${1:package_method}(${0:var})

endsnippet

# complex regex
snippet qrx
qr/
     ${0:regex}
/xms

endsnippet

#simpler regex
snippet qr/
qr/${0:regex}/x

endsnippet

#given
snippet given
given ($${1:var}) {
	${2:# cases}
	${0:# default}
}

endsnippet

# switch-like case
snippet when
when (${1:case}) {
	${0}
}

endsnippet

# hash slice
snippet hslice
@{ ${1:hash}  }{ ${0:array} }


endsnippet

# map
snippet map
map {  ${0: body }    }  ${1: @array } ;



endsnippet

# Pod stub
snippet ppod
=head1 NAME

${1:ClassName} - ${2:ShortDesc}

=head1 SYNOPSIS

  use $1;

  ${3:# synopsis...}

=head1 DESCRIPTION

${0:# longer description...}


=head1 INTERFACE


=head1 DEPENDENCIES


=head1 SEE ALSO


endsnippet

# Heading for a subroutine stub
snippet psub
=head2 ${1:MethodName}

${0:Summary....}

endsnippet

# Heading for inline subroutine pod
snippet psubi
=head2 ${1:MethodName}

${0:Summary...}


=cut
endsnippet

# inline documented subroutine
snippet subpod
=head2 $1

Summary of $1

=cut

sub ${1:subroutine_name} {
	${0}
}
endsnippet

# Subroutine signature
snippet parg
=over 2

=item
Arguments


=over 3

=item
C<${1:DataStructure}>

  ${2:Sample}


=back


=item
Return

=over 3


=item
C<${0:...return data}>


=back


=back



endsnippet

# Moose has
snippet has
has ${1:attribute} => (
	is	    => '${2:ro|rw}',
	isa 	=> '${3:Str|Int|HashRef|ArrayRef|etc}',
	default => sub {
		${4:defaultvalue}
	},
	${0:# other attributes}
);


endsnippet

# override
snippet override
override ${1:attribute} => sub {
	${2:# my $self = shift;};
	${0:# my ($self, $args) = @_;};
};


endsnippet

# use test classes
snippet tuse
use Test::More;
use Test::Deep; # (); # uncomment to stop prototype errors
use Test::Exception;

endsnippet

# local test lib
snippet tlib
use lib qw{ ./t/lib };

endsnippet

#test methods
snippet tmeths
$ENV{TEST_METHOD} = '${0:regex}';

endsnippet

# runtestclass
snippet trunner
use ${0:test_class};
$1->runtests();

endsnippet

# Test::Class-style test
snippet tsub
sub t${1:number}_${2:test_case} :Test(${3:num_of_tests}) {
	my $self = shift;
	${0}

}

endsnippet

# Test::Routine-style test
snippet trsub
test ${1:test_name} => { description => '${2:Description of test.}'} => sub {
	my ($self) = @_;
	${0}
};

endsnippet

#prep test method
snippet tprep
sub prep${1:number}_${2:test_case} :Test(startup) {
	my $self = shift;
	${0}
}

endsnippet

# cause failures to print stack trace
snippet debug_trace
use Carp; # 'verbose';
# cloak "die"
# warn "warning"
$SIG{'__DIE__'} = sub {
	require Carp; Carp::confess
};

endsnippet

snippet dump
use Data::Dump qw(dump);
warn dump ${1:variable}

endsnippet

snippet ddp
use DDP;
p ${1:variable}

endsnippet

snippet subtest
subtest '${1: test_name}' => sub {
	${2}
};
endsnippet

priority -50

###########################################################################
#                            TextMate Snippets                            #
###########################################################################
snippet ife "Conditional if..else (ife)"
if ($1) {
	${2:# body...}
}
else {
	${3:# else...}
}

endsnippet

snippet ifee "Conditional if..elsif..else (ifee)"
if ($1) {
	${2:# body...}
}
elsif ($3) {
	${4:# elsif...}
}
else {
	${5:# else...}
}

endsnippet

snippet xunless "Conditional one-line (unless)"
${1:expression} unless ${2:condition};

endsnippet

snippet xif "Conditional one-line (xif)"
${1:expression} if ${2:condition};

endsnippet

snippet sub "Function (sub)"
sub ${1:function_name} {
	${2:# body...}
}

endsnippet

snippet xfore "Loop one-line (xforeach)"
${1:expression} foreach @${2:array};

endsnippet

snippet xwhile "Loop one-line (xwhile)"
${1:expression} while ${2:condition};

endsnippet

snippet test "Test"
#!/usr/bin/env perl -w

use strict;
use Test::More tests => ${1:1};
use ${2:ModuleName};

ok(${3:assertion});

endsnippet

snippet class "class"
package ${1:ClassName};

${2:use parent qw(${3:ParentClass});}${2/.+/\n\n/}sub new {
	my $class = shift;
	$class = ref $class if ref $class;
	my $self = bless {}, $class;
	$self;
}

1;

endsnippet

snippet eval "eval"
local $@;
eval {
	${1:# do something risky...}
};
if (my $${2:exception} = $@) {
	${3:# handle failure...}
}

endsnippet

snippet if "if"
if ($1) {
	${2:# body...}
}

endsnippet

snippet slurp "slurp"
my $${1:var} = do { local $/ = undef; open my $fh, '<', ${2:$file}; <$fh> };

endsnippet

snippet unless "unless"
unless ($1) {
	${2:# body...}
}

endsnippet

snippet while "while"
while ($1) {
	${2:# body...}
}

endsnippet

snippet until "until"
until ($1) {
	${2:# body...}
}

endsnippet

# vim:ft=snippets:
# DUPLICATE SNIPPET: unless
